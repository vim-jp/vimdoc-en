---
layout: vimdoc
helpname: 'vim9'
---
<div id='vimCodeElement'>
<a class="Constant" href="vim9.html" name="vim9.txt">vim9.txt</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For&nbsp;<span class="Identifier">Vim version 8.2.</span>&nbsp;&nbsp;Last change: 2020 Sep 17<br>
<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Identifier">VIM REFERENCE MANUAL&nbsp;&nbsp;&nbsp;&nbsp;by Bram Moolenaar</span><br>
<br>
<br>
THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE<br>
<br>
Vim9 script commands and expressions.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#vim9" name="vim9">vim9</a><br>
<br>
Most expression help is in&nbsp;<a class="Identifier" href="eval.html">eval.txt</a>.&nbsp;&nbsp;This file is about the new syntax and<br>
features in Vim9 script.<br>
<br>
THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE<br>
<br>
<br>
1.&nbsp;&nbsp;What is Vim9 script?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="vim9.html#vim9-script">vim9-script</a><br>
2.&nbsp;&nbsp;Differences&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="vim9.html#vim9-differences">vim9-differences</a><br>
3.&nbsp;&nbsp;New style functions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="vim9.html#fast-functions">fast-functions</a><br>
4.&nbsp;&nbsp;Types&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="vim9.html#vim9-types">vim9-types</a><br>
5.&nbsp;&nbsp;Namespace, Import and Export&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="vim9.html#vim9script">vim9script</a><br>
6.&nbsp;&nbsp;Future work: classes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="vim9.html#vim9-classes">vim9-classes</a><br>
<br>
9.&nbsp;&nbsp;Rationale&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Identifier" href="vim9.html#vim9-rationale">vim9-rationale</a><br>
<br>
<span class="PreProc">==============================================================================</span><br>
<br>
1. What is Vim9 script?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#vim9-script" name="vim9-script">vim9-script</a><br>
<br>
THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE<br>
<br>
Vim script has been growing over time, while preserving backwards<br>
compatibility.&nbsp;&nbsp;That means bad choices from the past often can't be changed<br>
and compatibility with Vi restricts possible solutions.&nbsp;&nbsp;Execution is quite<br>
slow, each line is parsed every time it is executed.<br>
<br>
The main goal of Vim9 script is to drastically improve performance.&nbsp;&nbsp;This is<br>
accomplished by compiling commands into instructions that can be efficiently<br>
executed.&nbsp;&nbsp;An increase in execution speed of 10 to 100 times can be expected.<br>
<br>
A secondary goal is to avoid Vim-specific constructs and get closer to<br>
commonly used programming languages, such as JavaScript, TypeScript and Java.<br>
<br>
The performance improvements can only be achieved by not being 100% backwards<br>
compatible.&nbsp;&nbsp;For example, making function arguments available in the<br>
&quot;a:&quot; dictionary adds quite a lot of overhead.&nbsp;&nbsp;In a Vim9 function this<br>
dictionary is not available.&nbsp;&nbsp;Other differences are more subtle, such as how<br>
errors are handled.<br>
<br>
The Vim9 script syntax and semantics are used in:<br>
- a function defined with the&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;command<br>
- a script file where the first command is&nbsp;<a class="Comment" href="vim9.html#vim9script">vim9script</a><br>
- an autocommand defined in the context of the above<br>
<br>
When using&nbsp;<a class="Comment" href="eval.html#:function">:function</a>&nbsp;in a Vim9 script file the legacy syntax is used.<br>
However, this can be confusing and is therefore discouraged.<br>
<br>
Vim9 script and legacy Vim script can be mixed.&nbsp;&nbsp;There is no requirement to<br>
rewrite old scripts, they keep working as before.&nbsp;&nbsp;You may want to use a few<br>
<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;functions for code that needs to be fast.<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<br>
2. Differences from legacy Vim script&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#vim9-differences" name="vim9-differences">vim9-differences</a><br>
<br>
THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE<br>
<br>
<span class="PreProc">Comments starting with #</span><br>
<br>
In legacy Vim script comments start with double quote.&nbsp;&nbsp;In Vim9 script<br>
comments start with #.<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# declarations<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let count = 0&nbsp;&nbsp;# number of occurrences</div>
<br>
The reason is that a double quote can also be the start of a string. In many<br>
places, especially halfway through an expression with a line break, it's hard<br>
to tell what the meaning is, since both a string and a comment can be followed<br>
by arbitrary text.&nbsp;&nbsp;To avoid confusion only # comments are recognized.&nbsp;&nbsp;This<br>
is the same as in shell scripts and Python programs.<br>
<br>
In Vi # is a command to list text with numbers.&nbsp;&nbsp;In Vim9 script you can use<br>
<a class="Comment" href="various.html#:number">:number</a>&nbsp;for that.<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;101 number</div>
<br>
To improve readability there must be a space between a command and the #<br>
that starts a comment.&nbsp;&nbsp;<span class="Todo">Note</span>&nbsp;that #{ is the start of a dictionary, therefore<br>
it does not start a comment.<br>
<br>
<br>
<span class="PreProc">Vim9 functions</span><br>
<br>
A function defined with&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;is compiled.&nbsp;&nbsp;Execution is many times faster,<br>
often 10x to 100x times.<br>
<br>
Many errors are already found when compiling, before the function is executed.<br>
The syntax is strict, to enforce code that is easy to read and understand.<br>
<br>
Compilation is done when:<br>
- the function is first called<br>
- when the&nbsp;<a class="Comment" href="vim9.html#:defcompile">:defcompile</a>&nbsp;command is encountered in the script where the<br>
&nbsp;&nbsp;function was defined<br>
-&nbsp;<a class="Comment" href="vim9.html#:disassemble">:disassemble</a>&nbsp;is used for the function.<br>
- a function that is compiled calls the function or uses it as a function<br>
&nbsp;&nbsp;reference<br>
<br>
<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;has no options like&nbsp;<a class="Comment" href="eval.html#:function">:function</a>&nbsp;does: &quot;range&quot;, &quot;abort&quot;, &quot;dict&quot; or<br>
&quot;closure&quot;.&nbsp;&nbsp;A&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;function always aborts on an error, does not get a range<br>
passed and cannot be a &quot;dict&quot; function.<br>
<br>
The argument types and return type need to be specified.&nbsp;&nbsp;The &quot;any&quot; type can<br>
be used, type checking will then be done at runtime, like with legacy<br>
functions.<br>
<br>
Arguments are accessed by name, without &quot;a:&quot;, just like any other language.<br>
There is no &quot;a:&quot; dictionary or &quot;a:000&quot; list.<br>
<br>
Variable arguments are defined as the last argument, with a name and have a<br>
list type, similar to TypeScript.&nbsp;&nbsp;For example, a list of numbers:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def MyFunc(...itemlist: list&lt;number&gt;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for item in itemlist<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</div>
<br>
<br>
<span class="PreProc">Functions and variables are script-local by default</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#vim9-scopes" name="vim9-scopes">vim9-scopes</a><br>
When using&nbsp;<a class="Comment" href="eval.html#:function">:function</a>&nbsp;or&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;to specify a new function at the script level<br>
in a Vim9 script, the function is local to the script, as if &quot;s:&quot; was<br>
prefixed.&nbsp;&nbsp;Using the &quot;s:&quot; prefix is optional.&nbsp;&nbsp;To define or use a global<br>
function or variable the &quot;g:&quot; prefix should be used.&nbsp;&nbsp;For functions in an<br>
autoload script the &quot;name#&quot; prefix is sufficient.<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def ThisFunction()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# script-local<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def s:ThisFunction()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# script-local<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def g:ThatFunction()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# global<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def ThatFunction()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# global if no local ThatFunction()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def scriptname#function()&nbsp;&nbsp; # autoload</div>
<br>
When using&nbsp;<a class="Comment" href="eval.html#:function">:function</a>&nbsp;or&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;to specify a new function inside a function,<br>
the function is local to the function.&nbsp;&nbsp;It is not possible to define a<br>
script-local function inside a function. It is possible to define a global<br>
function, using the &quot;g:&quot; prefix.<br>
<br>
When referring to a function and no &quot;s:&quot; or &quot;g:&quot; prefix is used, Vim will<br>
prefer using a local function (in the function scope, script scope or<br>
imported) before looking for a global function.<br>
In all cases the function must be defined before used.&nbsp;&nbsp;That is when it is<br>
first called or when&nbsp;<a class="Comment" href="vim9.html#:defcompile">:defcompile</a>&nbsp;causes the call to be compiled.<br>
<br>
The result is that functions and variables without a namespace can usually be<br>
found in the script, either defined there or imported.&nbsp;&nbsp;Global functions and<br>
variables could be defined anywhere (good luck finding out where!).<br>
<br>
Global functions can still be defined and deleted at nearly any time.&nbsp;&nbsp;In<br>
Vim9 script script-local functions are defined once when the script is sourced<br>
and cannot be deleted or replaced.<br>
<br>
<br>
<span class="PreProc">Variable declarations with :let and :const</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#vim9-declaration" name="vim9-declaration">vim9-declaration</a><br>
Local variables need to be declared with&nbsp;<a class="Comment" href="eval.html#:let">:let</a>.&nbsp;&nbsp;Local constants need to be<br>
declared with&nbsp;<a class="Comment" href="eval.html#:const">:const</a>.&nbsp;&nbsp;We refer to both as &quot;variables&quot;.<br>
<br>
Variables can be local to a script, function or code block:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let script_var = 123<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def SomeFunc()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let func_var = script_var<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cond<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let block_var = func_var<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</div>
<br>
The variables are only visible in the block where they are defined and nested<br>
blocks.&nbsp;&nbsp;Once the block ends the variable is no longer accessible:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cond<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let inner = 5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let inner = 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo inner&nbsp;&nbsp;# Error!</div>
<br>
The declaration must be done earlier:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let inner: number<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cond<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inner = 5<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inner = 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo inner</div>
<br>
To intentionally avoid a variable being available later, a block can be used:<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let temp = 'temp'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo temp&nbsp;&nbsp;# Error!</div>
<br>
Declaring a variable with a type but without an initializer will initialize to<br>
zero, false or empty.<br>
<br>
An existing variable cannot be assigned to with&nbsp;<a class="Comment" href="eval.html#:let">:let</a>, since that implies a<br>
declaration.&nbsp;&nbsp;Global, window, tab, buffer and Vim variables can only be used<br>
without&nbsp;<a class="Comment" href="eval.html#:let">:let</a>, because they are not really declared, they can also be deleted<br>
with&nbsp;<a class="Comment" href="eval.html#:unlet">:unlet</a>.<br>
<br>
Variables and functions cannot shadow previously defined or imported variables<br>
and functions.<br>
Variables may shadow Ex commands, rename the variable if needed.<br>
<br>
Global variables and user defined functions must be prefixed with &quot;g:&quot;, also<br>
at the script level.<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let script_local = 'text'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:global = 'value'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let Funcref = g:ThatFunction</div>
<br>
Since &quot;&amp;opt = value&quot; is now assigning a value to option &quot;opt&quot;, &quot;:&amp;&quot; cannot be<br>
used to repeat a&nbsp;<a class="Comment" href="change.html#:substitute">:substitute</a>&nbsp;command.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#vim9-const" name="vim9-const">vim9-const</a><br>
In legacy Vim script &quot;const list = []&quot; would make the variable &quot;list&quot;<br>
immutable and also the value.&nbsp;&nbsp;Thus you cannot add items to the list.&nbsp;&nbsp;This<br>
differs from what many languages do. Vim9 script does it like TypeScript: only<br>
&quot;list&quot; is immutable, the value can be changed.<br>
<br>
One can use&nbsp;<span class="Comment">:const!</span>&nbsp;to make both the variable and the value immutable.&nbsp;&nbsp;Use<br>
this for composite structures that you want to make sure will not be modified.<br>
<br>
How this works:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const list = [1, 2]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list = [3, 4]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Error!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list[0] = 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# OK</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const! LIST = [1, 2]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIST = [3, 4]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Error!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIST[0] = 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Error!</div>
It is common to write constants as ALL_CAPS, but you don't have to.<br>
<br>
The constant only applies to the value itself, not what it refers to.<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cont females = [&quot;Mary&quot;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const! NAMES = [[&quot;John&quot;, &quot;Peter&quot;], females]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NAMES[0] = [&quot;Jack&quot;]&nbsp;&nbsp;&nbsp;&nbsp; # Error!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NAMES[0][0] = [&quot;Jack&quot;]&nbsp;&nbsp;# Error!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NAMES[1] = [&quot;Emma&quot;]&nbsp;&nbsp;&nbsp;&nbsp; # Error!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Names[1][0] = &quot;Emma&quot;&nbsp;&nbsp;&nbsp;&nbsp;# OK, now females[0] == &quot;Emma&quot;</div>
<br>
Rationale: TypeScript has no way to make the value immutable.&nbsp;&nbsp;One can use<br>
immutable types, but that quickly gets complicated for nested values.&nbsp;&nbsp;And<br>
with a type cast the value can be made mutable again, which means there is no<br>
guarantee the value won't change.&nbsp;&nbsp;Vim supports immutable values, in legacy<br>
script this was done with&nbsp;<a class="Comment" href="eval.html#:lockvar">:lockvar</a>.&nbsp;&nbsp;But that is an extra statement and also<br>
applies to nested values.&nbsp;&nbsp;Therefore the solution to use&nbsp;<span class="Comment">:const!</span>.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#E1092" name="E1092">E1092</a><br>
Declaring more than one variable at a time, using the unpack notation, is<br>
currently not supported:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let [v1, v2] = GetValues()&nbsp;&nbsp;# Error!</div>
That is because the type needs to be inferred from the list item type, which<br>
isn't that easy.<br>
<br>
<br>
<span class="PreProc">Omitting :call and :eval</span><br>
<br>
Functions can be called without&nbsp;<a class="Comment" href="eval.html#:call">:call</a>:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writefile(lines, 'file')</div>
Using&nbsp;<a class="Comment" href="eval.html#:call">:call</a>&nbsp;is still possible, but this is discouraged.<br>
<br>
A method call without&nbsp;<a class="Comment" href="eval.html#eval">eval</a>&nbsp;is possible, so long as the start is an<br>
identifier or can't be an Ex command.&nbsp;&nbsp;Examples:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myList-&gt;add(123)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:myList-&gt;add(123)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1, 2, 3]-&gt;Process()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#{a: 1, b: 2}-&gt;Process()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'a': 1, 'b': 2}-&gt;Process()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;foobar&quot;-&gt;Process()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&quot;foobar&quot;)-&gt;Process()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'foobar'-&gt;Process()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('foobar')-&gt;Process()</div>
<br>
In the rare case there is ambiguity between a function name and an Ex command,<br>
prepend &quot;:&quot; to make clear you want to use the Ex command.&nbsp;&nbsp;For example, there<br>
is both the&nbsp;<a class="Comment" href="change.html#:substitute">:substitute</a>&nbsp;command and the&nbsp;<a class="Comment" href="eval.html#substitute()">substitute()</a>&nbsp;function.&nbsp;&nbsp;When the<br>
line starts with&nbsp;<span class="Comment">substitute(</span>&nbsp;this will use the function. Prepend a colon to<br>
use the command instead:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:substitute(pattern (replacement (</div>
<br>
<span class="Todo">Note</span>&nbsp;that while variables need to be defined before they can be used,<br>
functions can be called before being defined.&nbsp;&nbsp;This is required to allow<br>
for cyclic dependencies between functions.&nbsp;&nbsp;It is slightly less efficient,<br>
since the function has to be looked up by name.&nbsp;&nbsp;And a typo in the function<br>
name will only be found when the function is called.<br>
<br>
<br>
<span class="PreProc">Omitting function()</span><br>
<br>
A user defined function can be used as a function reference in an expression<br>
without&nbsp;<a class="Comment" href="eval.html#function()">function()</a>. The argument types and return type will then be checked.<br>
The function must already have been defined.<br>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let Funcref = MyFunction</div>
<br>
When using&nbsp;<a class="Comment" href="eval.html#function()">function()</a>&nbsp;the resulting type is &quot;func&quot;, a function with any<br>
number of arguments and any return type.&nbsp;&nbsp;The function can be defined later.<br>
<br>
<br>
<span class="PreProc">Automatic line continuation</span><br>
<br>
In many cases it is obvious that an expression continues on the next line.&nbsp;&nbsp;In<br>
those cases there is no need to prefix the line with a backslash<br>
<a class="Identifier" href="repeat.html#line-continuation">line-continuation</a>.&nbsp;&nbsp;For example, when a list spans multiple lines:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let mylist = [<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'one',<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'two',<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]</div>
And when a dict spans multiple lines:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let mydict = #{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one: 1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two: 2,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div>
Function call:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = Func(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arg2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)</div>
<br>
For binary operators in expressions not in [], {} or () a line break is<br>
possible just before or after the operator.&nbsp;&nbsp;For example:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let text = lead<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .. middle<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .. end<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let total = start +<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end -<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;correction<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = positive<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? PosFunc(arg)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: NegFunc(arg)</div>
<br>
For a method call using &quot;-&gt;&quot; and a member using a dot, a line break is allowed<br>
before it:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = GetBuilder()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;BuilderSetWidth(333)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;BuilderSetHeight(777)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;BuilderBuild()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = MyDict<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.member</div>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#E1050" name="E1050">E1050</a><br>
To make it possible for the operator at the start of the line to be<br>
recognized, it is required to put a colon before a range.&nbsp;&nbsp;This will add<br>
&quot;start&quot; and print:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = start<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ print</div>
Like this:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = start + print</div>
<br>
This will assign &quot;start&quot; and print a line:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = start<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:+ print</div>
<br>
It is also possible to split a function header over multiple lines, in between<br>
arguments:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def MyFunc(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text: string,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;separator = '-'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;): string</div>
<br>
<span class="Todo">Notes</span>:<br>
- &quot;enddef&quot; cannot be used at the start of a continuation line, it ends the<br>
&nbsp;&nbsp;current function.<br>
- No line break is allowed in the LHS of an assignment.&nbsp;&nbsp;Specifically when<br>
&nbsp;&nbsp;unpacking a list&nbsp;<a class="Identifier" href="eval.html#:let-unpack">:let-unpack</a>. This is OK:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[var1, var2] =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Func()</div>
&nbsp;&nbsp;&nbsp;This does not work:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[var1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var2] =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Func()</div>
- No line break is allowed in between arguments of an&nbsp;<a class="Comment" href="eval.html#:echo">:echo</a>,&nbsp;<a class="Comment" href="eval.html#:execute">:execute</a>&nbsp;and<br>
&nbsp;&nbsp;similar commands.&nbsp;&nbsp;This is OK:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo [1,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2] [3,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4]</div>
&nbsp;&nbsp;&nbsp;This does not work:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo [1, 2]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3, 4]</div>
- No line break is allowed in the arguments of a lambda, between the &quot;{&quot; and<br>
&nbsp;&nbsp;&quot;-&gt;&quot;.&nbsp;&nbsp;This is OK:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter(list, {k, v -&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v &gt; 0})</div>
&nbsp;&nbsp;&nbsp;This does not work:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter(list, {k,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v -&gt; v &gt; 0})</div>
<br>
<br>
<span class="PreProc">No curly braces expansion</span><br>
<br>
<a class="Identifier" href="eval.html#curly-braces-names">curly-braces-names</a>&nbsp;cannot be used.<br>
<br>
<br>
<span class="PreProc">No :xit, :t, :append, :change or :insert</span><br>
<br>
These commands are too easily confused with local variable names.<br>
Instead of&nbsp;<a class="Comment" href="editing.html#:x">:x</a>&nbsp;or&nbsp;<a class="Comment" href="editing.html#:xit">:xit</a>&nbsp;you can use&nbsp;<a class="Comment" href="editing.html#:exit">:exit</a>.<br>
Instead of&nbsp;<a class="Comment" href="change.html#:t">:t</a>&nbsp;you can use&nbsp;<a class="Comment" href="change.html#:copy">:copy</a>.<br>
<br>
<br>
<span class="PreProc">Comparators</span><br>
<br>
The&nbsp;<a class="Type" href="options.html#'ignorecase'">'ignorecase'</a>&nbsp;option is not used for comparators that use strings.<br>
<br>
<br>
<span class="PreProc">White space</span><br>
<br>
Vim9 script enforces proper use of white space.&nbsp;&nbsp;This is no longer allowed:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let var=234&nbsp;&nbsp;&nbsp;&nbsp; # Error!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let var= 234&nbsp;&nbsp;&nbsp;&nbsp;# Error!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let var =234&nbsp;&nbsp;&nbsp;&nbsp;# Error!</div>
There must be white space before and after the &quot;=&quot;:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let var = 234&nbsp;&nbsp; # OK</div>
White space must also be put before the # that starts a comment after a<br>
command:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let var = 234# Error!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let var = 234 # OK</div>
<br>
White space is required around most operators.<br>
<br>
White space is not allowed:<br>
- Between a function name and the &quot;(&quot;:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call Func (arg)&nbsp;&nbsp;&nbsp;&nbsp;# Error!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call Func<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ (arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Error!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call Func(arg)&nbsp;&nbsp;&nbsp;&nbsp; # OK<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call Func(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ arg)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# OK<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call Func(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ arg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # OK<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ )</div>
<br>
<br>
<span class="PreProc">Conditions and expressions</span><br>
<br>
Conditions and expressions are mostly working like they do in JavaScript.&nbsp;&nbsp;A<br>
difference is made where JavaScript does not work like most people expect.<br>
Specifically, an empty list is falsey.<br>
<br>
Any type of variable can be used as a condition, there is no error, not even<br>
for using a list or job.&nbsp;&nbsp;This is very much like JavaScript, but there are a<br>
few exceptions.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="PreProc">type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRUE when</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v:true or 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;non-zero<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; non-zero<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;non-empty<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;non-empty<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;non-empty (different from JavaScript)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dictionary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;non-empty (different from JavaScript)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when there is a function name<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;special&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; v:true<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when not NULL<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when not NULL<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when not NULL<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when not NULL (TODO: when isTrue() returns v:true)<br>
<br>
The boolean operators &quot;||&quot; and &quot;&amp;&amp;&quot; do not change the value:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 || 2&nbsp;&nbsp; == 8<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 || 2&nbsp;&nbsp; == 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 || ''&nbsp;&nbsp;== ''<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 &amp;&amp; 2&nbsp;&nbsp; == 2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 &amp;&amp; 2&nbsp;&nbsp; == 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 &amp;&amp; 0&nbsp;&nbsp; == 0<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[] &amp;&amp; 2&nbsp;&nbsp;== []</div>
<br>
When using&nbsp;<span class="Comment">..</span>&nbsp;for string concatenation arguments of simple types are always<br>
converted to string.<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'hello ' .. 123&nbsp;&nbsp;== 'hello 123'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'hello ' .. v:true&nbsp;&nbsp;== 'hello v:true'</div>
<br>
Simple types are string, float, special and bool.&nbsp;&nbsp;For other types&nbsp;<a class="Identifier" href="eval.html#string()">string()</a><br>
can be used.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#false" name="false">false</a>&nbsp;<a class="Constant" href="vim9.html#true" name="true">true</a><br>
In Vim9 script one can use &quot;true&quot; for v:true and &quot;false&quot; for v:false.<br>
<br>
Indexing a string with&nbsp;<span class="Special">[idx]</span>&nbsp;or [idx, idx] uses character indexes instead of<br>
byte indexes. Example:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 'bár'[1]</div>
In legacy script this results in the character 0xc3 (an illegal byte), in Vim9<br>
script this results in the string 'á'.<br>
<br>
<br>
<span class="PreProc">What to watch out for</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#vim9-gotchas" name="vim9-gotchas">vim9-gotchas</a><br>
Vim9 was designed to be closer to often used programming languages, but at the<br>
same time tries to support the legacy Vim commands.&nbsp;&nbsp;Some compromises had to<br>
be made.&nbsp;&nbsp;Here is a summary of what might be unexpected.<br>
<br>
Ex command ranges need to be prefixed with a colon.<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# legacy Vim&#0058; shifts the previous line to the right<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt;func()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Vim9&#0058; method call in continuation line<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Vim9&#0058; shifts the previous line to the right</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%s/a/b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# legacy Vim&#0058; substitute on all lines<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = alongname<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % another&nbsp;&nbsp;# Vim9&#0058; line continuation without a backslash<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:%s/a/b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Vim9&#0058; substitute on all lines<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'text'-&gt;func()&nbsp;&nbsp;# Vim9&#0058; method call<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:'t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # legacy Vim&#0058; jump to mark m</div>
<br>
Some Ex commands can be confused with assignments in Vim9 script:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:name = value&nbsp;&nbsp;# assignment<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g:pattern:cmd&nbsp;&nbsp; # invalid command - ERROR<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:g:pattern:cmd&nbsp;&nbsp;# :global command</div>
<br>
Functions defined with&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;compile the whole function.&nbsp;&nbsp;Legacy functions<br>
can bail out, and the following lines are not parsed:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func Maybe()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !has('feature')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use-feature<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunc</div>
Vim9 functions are compiled as a whole:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def Maybe()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if !has('feature')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use-feature&nbsp;&nbsp;# May give compilation error<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
For a workaround, split it in two functions:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func Maybe()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if has('feature')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call MaybyInner()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endfunc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if has('feature')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def MaybeInner()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use-feature<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif</div>
Or put the unsupported code inside an&nbsp;<a class="Comment" href="eval.html#:if">if</a>&nbsp;with a constant expression that<br>
evaluates to false:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def Maybe()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if has('feature')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use-feature<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<span class="Todo">Note</span>&nbsp;that for unrecognized commands there is no check for &quot;|&quot; and a following<br>
command.&nbsp;&nbsp;This will give an error for missing&nbsp;<a class="Comment" href="eval.html#:endif">endif</a>:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def Maybe()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if has('feature') | use-feature | endif<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
<span class="PreProc">==============================================================================</span><br>
<br>
3. New style functions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#fast-functions" name="fast-functions">fast-functions</a><br>
<br>
THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#:def" name=":def">:def</a><br>
:def[!]&nbsp;<span class="Special">{name}</span>(<span class="Special">[arguments]</span>)[:&nbsp;<span class="Special">{return-type}</span>]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define a new function by the name&nbsp;<span class="Special">{name}</span>.&nbsp;&nbsp;The body of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the function follows in the next lines, until the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matching&nbsp;<a class="Comment" href="vim9.html#:enddef">:enddef</a>.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When&nbsp;<span class="Special">{return-type}</span>&nbsp;is omitted or is &quot;void&quot; the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function is not expected to return anything.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{arguments}</span>&nbsp;is a sequence of zero or more argument<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;declarations.&nbsp;&nbsp;There are three forms:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{name}</span>:&nbsp;<span class="Special">{type}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{name}</span>&nbsp;=&nbsp;<span class="Special">{value}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{name}</span>:&nbsp;<span class="Special">{type}</span>&nbsp;=&nbsp;<span class="Special">{value}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The first form is a mandatory argument, the caller<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;must always provide them.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The second and third form are optional arguments.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When the caller omits an argument the&nbsp;<span class="Special">{value}</span>&nbsp;is used.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The function will be compiled into instructions when<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;called, or when&nbsp;<a class="Comment" href="vim9.html#:disassemble">:disassemble</a>&nbsp;or&nbsp;<a class="Comment" href="vim9.html#:defcompile">:defcompile</a>&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;used.&nbsp;&nbsp;Syntax and type errors will be produced at that<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It is possible to nest&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;inside another&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Comment" href="eval.html#:function">:function</a>&nbsp;up to about 50 levels deep.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[!] is used as with&nbsp;<a class="Comment" href="eval.html#:function">:function</a>.&nbsp;&nbsp;<span class="Todo">Note</span>&nbsp;that in Vim9<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;script script-local functions cannot be deleted or<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redefined later in the same script.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#:enddef" name=":enddef">:enddef</a><br>
:enddef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; End of a function defined with&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>. It should be on<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a line by its own.<br>
<br>
<br>
If the script the function is defined in is Vim9 script, then script-local<br>
variables can be accessed without the &quot;s:&quot; prefix.&nbsp;&nbsp;They must be defined<br>
before the function is compiled.&nbsp;&nbsp;If the script the function is defined in is<br>
legacy script, then script-local variables must be accessed with the &quot;s:&quot;<br>
prefix and they do not need to exist (they can be deleted any time).<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#:defc" name=":defc">:defc</a>&nbsp;<a class="Constant" href="vim9.html#:defcompile" name=":defcompile">:defcompile</a><br>
:defc[ompile]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Compile functions defined in the current script that<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;were not compiled yet.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This will report errors found during the compilation.<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#:disa" name=":disa">:disa</a>&nbsp;<a class="Constant" href="vim9.html#:disassemble" name=":disassemble">:disassemble</a><br>
:disa[ssemble]&nbsp;<span class="Special">{func}</span>&nbsp;&nbsp; Show the instructions generated for&nbsp;<span class="Special">{func}</span>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is for debugging and testing.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Todo">Note</span>&nbsp;that for command line completion of&nbsp;<span class="Special">{func}</span>&nbsp;you<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can prepend &quot;s:&quot; to find script-local functions.<br>
<br>
<span class="PreProc">Limitations</span><br>
<br>
Local variables will not be visible to string evaluation.&nbsp;&nbsp;For example:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def EvalString(): list&lt;string&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let list = ['aa', 'bb', 'cc', 'dd']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return range(1, 2)-&gt;map('list[v:val]')<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
The map argument is a string expression, which is evaluated without the<br>
function scope.&nbsp;&nbsp;Instead, use a lambda:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def EvalString(): list&lt;string&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let list = ['aa', 'bb', 'cc', 'dd']<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return range(1, 2)-&gt;map({ _, v -&gt; list[v] })<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enddef</div>
<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<br>
4. Types&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#vim9-types" name="vim9-types">vim9-types</a><br>
<br>
THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE<br>
<br>
The following builtin types are supported:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blob<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list&lt;<span class="Special">{type}</span>&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dict&lt;<span class="Special">{type}</span>&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;job<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func:&nbsp;<span class="Special">{type}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func(<span class="Special">{type}</span>, ...)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func(<span class="Special">{type}</span>, ...):&nbsp;<span class="Special">{type}</span><br>
<br>
Not supported yet:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tuple&lt;a:&nbsp;<span class="Special">{type}</span>, b:&nbsp;<span class="Special">{type}</span>, ...&gt;<br>
<br>
These types can be used in declarations, but no value will have this type:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Special">{type}</span>|<span class="Special">{type}</span>&nbsp;&nbsp;<span class="Special">{not implemented yet}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any<br>
<br>
There is no array type, use list&lt;<span class="Special">{type}</span>&gt; instead.&nbsp;&nbsp;For a list constant an<br>
efficient implementation is used that avoids allocating lot of small pieces of<br>
memory.<br>
<br>
A partial and function can be declared in more or less specific ways:<br>
func&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any kind of function reference, no type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checking for arguments or return value<br>
func:&nbsp;<span class="Special">{type}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;any number and type of arguments with specific<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return type<br>
func(<span class="Special">{type}</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function with argument type, does not return<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a value<br>
func(<span class="Special">{type}</span>):&nbsp;<span class="Special">{type}</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function with argument type and return type<br>
func(?<span class="Special">{type}</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function with type of optional argument, does<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not return a value<br>
func(...<span class="Special">{type}</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function with type of variable number of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments, does not return a value<br>
func(<span class="Special">{type}</span>, ?<span class="Special">{type}</span>, ...<span class="Special">{type}</span>):&nbsp;<span class="Special">{type}</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function with:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- type of mandatory argument<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- type of optional argument<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- type of variable number of arguments<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- return type<br>
<br>
If the return type is &quot;void&quot; the function does not return a value.<br>
<br>
The reference can also be a&nbsp;<a class="Identifier" href="eval.html#Partial">Partial</a>, in which case it stores extra arguments<br>
and/or a dictionary, which are not visible to the caller.&nbsp;&nbsp;Since they are<br>
called in the same way the declaration is the same.<br>
<br>
Custom types can be defined with&nbsp;<span class="Comment">:type</span>:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:type MyList list&lt;string&gt;</div>
Custom types must start with a capital letter, to avoid name clashes with<br>
builtin types added later, similarly to user functions.<br>
<span class="Special">{not implemented yet}</span><br>
<br>
And classes and interfaces can be used as types:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:class MyClass<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let mine: MyClass</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:interface MyInterface<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let mine: MyInterface</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:class MyTemplate&lt;Targ&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let mine: MyTemplate&lt;number&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let mine: MyTemplate&lt;string&gt;</div>
<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:class MyInterface&lt;Targ&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let mine: MyInterface&lt;number&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:let mine: MyInterface&lt;string&gt;</div>
<span class="Special">{not implemented yet}</span><br>
<br>
<br>
Variable types and type casting&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#variable-types" name="variable-types">variable-types</a><br>
<br>
Variables declared in Vim9 script or in a&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;function have a type, either<br>
specified explicitly or inferred from the initialization.<br>
<br>
Global, buffer, window and tab page variables do not have a specific type, the<br>
value can be changed at any time, possibly changing the type.&nbsp;&nbsp;Therefore, in<br>
compiled code the &quot;any&quot; type is assumed.<br>
<br>
This can be a problem when the &quot;any&quot; type is undesired and the actual type is<br>
expected to always be the same.&nbsp;&nbsp;For example, when declaring a list:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let l: list&lt;number&gt; = [1, g:two]</div>
This will give an error, because &quot;g:two&quot; has type &quot;any&quot;.&nbsp;&nbsp;To avoid this, use a<br>
type cast:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let l: list&lt;number&gt; = [1, &lt;number&gt;g:two]</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#type-casting" name="type-casting">type-casting</a><br>
The compiled code will then check that &quot;g:two&quot; is a number at runtime and give<br>
an error if it isn't.&nbsp;&nbsp;This is called type casting.<br>
<br>
The syntax of a type cast is:&nbsp;&nbsp;&quot;&lt;&quot;&nbsp;<span class="Special">{type}</span>&nbsp;&quot;&gt;&quot;.&nbsp;&nbsp;There cannot be white space<br>
after the &quot;&lt;&quot; or before the &quot;&gt;&quot; (to avoid them being confused with<br>
smaller-than and bigger-than operators).<br>
<br>
The semantics is that, if needed, a runtime type check is performed.&nbsp;&nbsp;The<br>
value is not actually changed.&nbsp;&nbsp;If you need to change the type, e.g. to change<br>
it to a string, use the&nbsp;<a class="Identifier" href="eval.html#string()">string()</a>&nbsp;function.&nbsp;&nbsp;Or use&nbsp;<a class="Identifier" href="eval.html#str2nr()">str2nr()</a>&nbsp;to convert a<br>
string to a number.<br>
<br>
<br>
Type inference&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#type-inference" name="type-inference">type-inference</a><br>
<br>
In general: Whenever the type is clear it can be omitted.&nbsp;&nbsp;For example, when<br>
declaring a variable and giving it a value:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let var = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # infers number type<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let var = 'hello'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # infers string type</div>
<br>
The type of a list and dictionary comes from the common type of the values.<br>
If the values all have the same type, that type is used for the list or<br>
dictionary.&nbsp;&nbsp;If there is a mix of types, the &quot;any&quot; type is used.<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1, 2, 3]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list&lt;number&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;['a', 'b', 'c'] list&lt;string&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1, 'x', 3]&nbsp;&nbsp;&nbsp;&nbsp; list&lt;any&gt;</div>
<br>
<br>
Stricter type checking&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#type-checking" name="type-checking">type-checking</a><br>
<br>
In legacy Vim script, where a number was expected, a string would be<br>
automatically converted to a number.&nbsp;&nbsp;This was convenient for an actual number<br>
such as &quot;123&quot;, but leads to unexpected problems (but no error message) if the<br>
string doesn't start with a number.&nbsp;&nbsp;Quite often this leads to hard-to-find<br>
bugs.<br>
<br>
In Vim9 script this has been made stricter.&nbsp;&nbsp;In most places it works just as<br>
before, if the value used matches the expected type.&nbsp;&nbsp;There will sometimes be<br>
an error, thus breaking backwards compatibility.&nbsp;&nbsp;For example:<br>
- Using a number other than 0 or 1 where a boolean is expected.&nbsp;&nbsp;<a class="Constant" href="vim9.html#E1023" name="E1023">E1023</a><br>
- Using a string value when setting a number options.<br>
- Using a number where a string is expected.&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#E1024" name="E1024">E1024</a><br>
<br>
<span class="PreProc">==============================================================================</span><br>
<br>
5.&nbsp;&nbsp;Namespace, Import and Export<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#vim9script" name="vim9script">vim9script</a>&nbsp;<a class="Constant" href="vim9.html#vim9-export" name="vim9-export">vim9-export</a>&nbsp;<a class="Constant" href="vim9.html#vim9-import" name="vim9-import">vim9-import</a><br>
<br>
THIS IS STILL UNDER DEVELOPMENT - ANYTHING CAN BREAK - ANYTHING CAN CHANGE<br>
<br>
A Vim9 script can be written to be imported.&nbsp;&nbsp;This means that everything in<br>
the script is local, unless exported.&nbsp;&nbsp;Those exported items, and only those<br>
items, can then be imported in another script.<br>
<br>
You can cheat by using the global namespace explicitly.&nbsp;&nbsp;We will assume here<br>
that you don't do that.<br>
<br>
<br>
<span class="PreProc">Namespace</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#:vim9script" name=":vim9script">:vim9script</a>&nbsp;<a class="Constant" href="vim9.html#:vim9" name=":vim9">:vim9</a><br>
To recognize a file that can be imported the&nbsp;<a class="Comment" href="vim9.html#vim9script">vim9script</a>&nbsp;statement must<br>
appear as the first statement in the file.&nbsp;&nbsp;It tells Vim to interpret the<br>
script in its own namespace, instead of the global namespace.&nbsp;&nbsp;If a file<br>
starts with:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let myvar = 'yes'</div>
Then &quot;myvar&quot; will only exist in this file.&nbsp;&nbsp;While without&nbsp;<a class="Comment" href="vim9.html#vim9script">vim9script</a>&nbsp;it would<br>
be available as&nbsp;<span class="Comment">g:myvar</span>&nbsp;from any other script and function.<br>
<br>
The variables at the file level are very much like the script-local &quot;s:&quot;<br>
variables in legacy Vim script, but the &quot;s:&quot; is omitted.&nbsp;&nbsp;And they cannot be<br>
deleted.<br>
<br>
In Vim9 script the global &quot;g:&quot; namespace can still be used as before.&nbsp;&nbsp;And the<br>
&quot;w:&quot;, &quot;b:&quot; and &quot;t:&quot; namespaces.&nbsp;&nbsp;These have in common that variables are not<br>
declared and they can be deleted.<br>
<br>
A side effect of&nbsp;<a class="Comment" href="vim9.html#:vim9script">:vim9script</a>&nbsp;is that the&nbsp;<a class="Type" href="options.html#'cpoptions'">'cpoptions'</a>&nbsp;option is set to the<br>
Vim default value, like with:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:set cpo&amp;vim</div>
One of the effects is that&nbsp;<a class="Identifier" href="repeat.html#line-continuation">line-continuation</a>&nbsp;is always enabled.<br>
The original value of&nbsp;<a class="Type" href="options.html#'cpoptions'">'cpoptions'</a>&nbsp;is restored at the end of the script.<br>
<br>
<br>
<span class="PreProc">Export</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#:export" name=":export">:export</a>&nbsp;<a class="Constant" href="vim9.html#:exp" name=":exp">:exp</a><br>
Exporting an item can be written as:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;export const EXPORTED_CONST = 1234<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;export let someValue = ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;export def MyFunc() ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;export class MyClass ...</div>
<br>
As this suggests, only constants, variables,&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;functions and classes can<br>
be exported. {classes are not implemented yet}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#E1042" name="E1042">E1042</a><br>
<a class="Comment" href="vim9.html#:export">:export</a>&nbsp;can only be used in Vim9 script, at the script level.<br>
<br>
<br>
<span class="PreProc">Import</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#:import" name=":import">:import</a>&nbsp;<a class="Constant" href="vim9.html#:imp" name=":imp">:imp</a>&nbsp;<a class="Constant" href="vim9.html#E1094" name="E1094">E1094</a><br>
The exported items can be imported individually in another Vim9 script:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import EXPORTED_CONST from &quot;thatscript.vim&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import MyClass from &quot;myclass.vim&quot;</div>
<br>
To import multiple items at the same time:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import {someValue, MyClass} from &quot;thatscript.vim&quot;</div>
<br>
In case the name is ambiguous, another name can be specified:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import MyClass as ThatClass from &quot;myclass.vim&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import {someValue, MyClass as ThatClass} from &quot;myclass.vim&quot;</div>
<br>
To import all exported items under a specific identifier:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import * as That from 'thatscript.vim'</div>
<br>
<span class="Special">{not implemented yet: using &quot;This as That&quot;}</span><br>
<br>
Then you can use &quot;That.EXPORTED_CONST&quot;, &quot;That.someValue&quot;, etc.&nbsp;&nbsp;You are free<br>
to choose the name &quot;That&quot;, but it is highly recommended to use the name of the<br>
script file to avoid confusion.<br>
<br>
<a class="Comment" href="vim9.html#:import">:import</a>&nbsp;can also be used in legacy Vim script.&nbsp;&nbsp;The imported items still<br>
become script-local, even when the &quot;s:&quot; prefix is not given.<br>
<br>
The script name after&nbsp;<a class="Comment" href="vim9.html#:import">import</a>&nbsp;can be:<br>
- A relative path, starting &quot;.&quot; or &quot;..&quot;.&nbsp;&nbsp;This finds a file relative to the<br>
&nbsp;&nbsp;location of the script file itself.&nbsp;&nbsp;This is useful to split up a large<br>
&nbsp;&nbsp;plugin into several files.<br>
- An absolute path, starting with &quot;/&quot; on Unix or &quot;D:/&quot; on MS-Windows.&nbsp;&nbsp;This<br>
&nbsp;&nbsp;will be rarely used.<br>
- A path not being relative or absolute.&nbsp;&nbsp;This will be found in the<br>
&nbsp;&nbsp;&quot;import&quot; subdirectories of&nbsp;<a class="Type" href="options.html#'runtimepath'">'runtimepath'</a>&nbsp;entries.&nbsp;&nbsp;The name will usually be<br>
&nbsp;&nbsp;longer and unique, to avoid loading the wrong file.<br>
<br>
Once a vim9 script file has been imported, the result is cached and used the<br>
next time the same script is imported.&nbsp;&nbsp;It will not be read again.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#:import-cycle" name=":import-cycle">:import-cycle</a><br>
The&nbsp;<a class="Comment" href="vim9.html#:import">import</a>&nbsp;commands are executed when encountered.&nbsp;&nbsp;If that script (directly<br>
or indirectly) imports the current script, then items defined after the<br>
<a class="Comment" href="vim9.html#:import">import</a>&nbsp;won't be processed yet.&nbsp;&nbsp;Therefore cyclic imports can exist, but may<br>
result in undefined items.<br>
<br>
<br>
<span class="PreProc">Import in an autoload script</span><br>
<br>
For optimal startup speed, loading scripts should be postponed until they are<br>
actually needed.&nbsp;&nbsp;A recommended mechanism:<br>
<br>
1. In the plugin define user commands, functions and/or mappings that refer to<br>
&nbsp;&nbsp; an autoload script.<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;command -nargs=1 SearchForStuff call searchfor#Stuff(&lt;f-args&gt;)</div>
<br>
&nbsp;&nbsp;&nbsp; This goes in .../plugin/anyname.vim.&nbsp;&nbsp;&quot;anyname.vim&quot; can be freely chosen.<br>
<br>
2. In the autoload script do the actual work.&nbsp;&nbsp;You can import items from<br>
&nbsp;&nbsp; other files to split up functionality in appropriate pieces.<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;import FilterFunc from &quot;../import/someother.vim&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def searchfor#Stuff(arg: string)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let filtered = FilterFunc(arg)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</div>
&nbsp;&nbsp;&nbsp; This goes in .../autoload/searchfor.vim.&nbsp;&nbsp;&quot;searchfor&quot; in the file name<br>
&nbsp;&nbsp; must be exactly the same as the prefix for the function name, that is how<br>
&nbsp;&nbsp; Vim finds the file.<br>
<br>
3. Other functionality, possibly shared between plugins, contains the exported<br>
&nbsp;&nbsp; items and any private items.<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vim9script<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let localVar = 'local'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;export def FilterFunc(arg: string): string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</div>
&nbsp;&nbsp;&nbsp; This goes in .../import/someother.vim.<br>
<br>
When compiling a&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;function and a function in an autoload script is<br>
encountered, the script is not loaded until the&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;function is called.<br>
<br>
<br>
<span class="PreProc">Import in legacy Vim script</span><br>
<br>
If an&nbsp;<a class="Comment" href="vim9.html#:import">import</a>&nbsp;statement is used in legacy Vim script, the script-local &quot;s:&quot;<br>
namespace will be used for the imported item, even when &quot;s:&quot; is not specified.<br>
<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<br>
6. Future work: classes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#vim9-classes" name="vim9-classes">vim9-classes</a><br>
<br>
Above &quot;class&quot; was mentioned a few times, but it has not been implemented yet.<br>
Most of Vim9 script can be created without this funcionality, and since<br>
implementing classes is going to be a lot of work, it is left for the future.<br>
For now we'll just make sure classes can be added later.<br>
<br>
Thoughts:<br>
-&nbsp;<span class="Comment">class</span>&nbsp;/&nbsp;<span class="Comment">endclass</span>, everything in one file<br>
- Class names are always CamelCase<br>
- Single constructor<br>
- Single inheritance with&nbsp;<span class="Comment">class ThisClass extends BaseClass</span><br>
-&nbsp;<span class="Comment">abstract class</span><br>
-&nbsp;<span class="Comment">interface</span>&nbsp;(Abstract class without any implementation)<br>
-&nbsp;<span class="Comment">class SomeClass implements SomeInterface</span><br>
- Generics for class:&nbsp;<span class="Comment">class &lt;Tkey, Tentry&gt;</span><br>
- Generics for function:&nbsp;<span class="Comment">def &lt;Tkey&gt; GetLast(key: Tkey)</span><br>
<br>
Again, much of this is from TypeScript.<br>
<br>
Some things that look like good additions:<br>
- Use a class as an interface (like Dart)<br>
- Extend a class with methods, using an import (like Dart)<br>
<br>
An important class that will be provided is &quot;Promise&quot;.&nbsp;&nbsp;Since Vim is single<br>
threaded, connecting asynchronous operations is a natural way of allowing<br>
plugins to do their work without blocking the user.&nbsp;&nbsp;It's a uniform way to<br>
invoke callbacks and handle timeouts and errors.<br>
<br>
<span class="PreProc">==============================================================================</span><br>
<br>
9. Rationale&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="Constant" href="vim9.html#vim9-rationale" name="vim9-rationale">vim9-rationale</a><br>
<br>
<span class="PreProc">The :def command</span><br>
<br>
Plugin writers have asked for a much faster Vim script.&nbsp;&nbsp;Investigations have<br>
shown that keeping the existing semantics of function calls make this close to<br>
impossible, because of the overhead involved with calling a function, setting<br>
up the local function scope and executing lines.&nbsp;&nbsp;There are many details that<br>
need to be handled, such as error messages and exceptions.&nbsp;&nbsp;The need to create<br>
a dictionary for a: and l: scopes, the a:000 list and several others add too<br>
much overhead that cannot be avoided.<br>
<br>
Therefore the&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;method to define a new-style function had to be added,<br>
which allows for a function with different semantics.&nbsp;&nbsp;Most things still work<br>
as before, but some parts do not.&nbsp;&nbsp;A new way to define a function was<br>
considered the best way to separate the old-style code from Vim9 script code.<br>
<br>
Using &quot;def&quot; to define a function comes from Python. Other languages use<br>
&quot;function&quot; which clashes with legacy Vim script.<br>
<br>
<br>
<span class="PreProc">Type checking</span><br>
<br>
When compiling lines of Vim commands into instructions as much as possible<br>
should be done at compile time.&nbsp;&nbsp;Postponing it to runtime makes the execution<br>
slower and means mistakes are found only later.&nbsp;&nbsp;For example, when<br>
encountering the &quot;+&quot; character and compiling this into a generic add<br>
instruction, at execution time the instruction would have to inspect the type<br>
of the arguments and decide what kind of addition to do.&nbsp;&nbsp;And when the<br>
type is dictionary throw an error.&nbsp;&nbsp;If the types are known to be numbers then<br>
an &quot;add number&quot; instruction can be used, which is faster.&nbsp;&nbsp;The error can be<br>
given at compile time, no error handling is needed at runtime, adding two<br>
numbers cannot fail.<br>
<br>
The syntax for types is similar to Java, since it is easy to understand and<br>
widely used.&nbsp;&nbsp;The type names are what were used in Vim before, with some<br>
additions such as &quot;void&quot; and &quot;bool&quot;.<br>
<br>
<br>
<span class="PreProc">Removing clutter and weirdness</span><br>
<br>
Once decided that&nbsp;<a class="Comment" href="vim9.html#:def">:def</a>&nbsp;functions have different syntax than legacy functions,<br>
we are free to add improvements to make the code more familiar for users who<br>
know popular programming languages.&nbsp;&nbsp;In other words: remove weird things that<br>
only Vim uses.<br>
<br>
We can also remove clutter, mainly things that were done to make Vim script<br>
backwards compatible with good old Vi commands.<br>
<br>
Examples:<br>
- Drop&nbsp;<a class="Comment" href="eval.html#:call">:call</a>&nbsp;for calling a function and&nbsp;<a class="Comment" href="eval.html#:eval">:eval</a>&nbsp;for manipulating data.<br>
- Drop using a leading backslash for line continuation, automatically figure<br>
&nbsp;&nbsp;out where an expression ends.<br>
<br>
However, this does require that some things need to change:<br>
- Comments start with # instead of &quot;, to avoid confusing them with strings.<br>
- Ex command ranges need to be prefixed with a colon, to avoid confusion with<br>
&nbsp;&nbsp;expressions (single quote can be a string or a mark, &quot;/&quot; can be divide or a<br>
&nbsp;&nbsp;search command, etc.).<br>
<br>
Goal is to limit the differences.&nbsp;&nbsp;A good criteria is that when the old syntax<br>
is used you are very likely to get an error message.<br>
<br>
<br>
<span class="PreProc">TypeScript syntax and semantics</span><br>
<br>
Script writers have complained that the Vim script syntax is unexpectedly<br>
different from what they are used to.&nbsp;&nbsp;To reduce this complaint popular<br>
languages are used as an example.&nbsp;&nbsp;At the same time, we do not want to abandon<br>
the well-known parts of legacy Vim script.<br>
<br>
Since Vim already uses&nbsp;<a class="Comment" href="eval.html#:let">:let</a>&nbsp;and&nbsp;<a class="Comment" href="eval.html#:const">:const</a>&nbsp;and optional type checking is<br>
desirable, the JavaScript/TypeScript syntax fits best for variable<br>
declarations:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const greeting = 'hello'&nbsp;&nbsp;# string type is inferred<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let name: string<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name = 'John'</div>
<br>
Expression evaluation was already close to what JavaScript and other languages<br>
are doing.&nbsp;&nbsp;Some details are unexpected and can be fixed.&nbsp;&nbsp;For example how the<br>
|| and &amp;&amp; operators work.&nbsp;&nbsp;Legacy Vim script:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let value = 44<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = value || 0&nbsp;&nbsp;# result == 1</div>
<br>
Vim9 script works like JavaScript/TypeScript, keep the value:<br>
<div class="helpExample">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let value = 44<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = value || 0&nbsp;&nbsp;# result == 44</div>
<br>
Another reason why TypeScript can be used as an example for Vim9 script is the<br>
mix of static typing (a variable always has a known value type) and dynamic<br>
typing (a variable can have different types, this hanges at runtime).&nbsp;&nbsp;Since<br>
legacy Vim script is dynamically typed and a lot of existing functionality<br>
(esp. builtin functions) depends on that, while static typing allows for much<br>
faster execution, we need to have this mix in Vim9 script.<br>
<br>
There is no intention to completely match TypeScript syntax and semantics.&nbsp;&nbsp;We<br>
just want to take those parts that we can use for Vim and we expect Vim users<br>
will be happy with.&nbsp;&nbsp;TypeScript is a complex language with its own history,<br>
advantages and disadvantages.&nbsp;&nbsp;To get an idea of the disadvantages read the<br>
book: &quot;JavaScript: The Good Parts&quot;.&nbsp;&nbsp;Or find the article &quot;TypeScript: the good<br>
parts&quot; and read the &quot;Things to avoid&quot; section.<br>
<br>
People familiar with other languages (Java, Python, etc.) will also find<br>
things in TypeScript that they do not like or do not understand.&nbsp;&nbsp;We'll try to<br>
avoid those things.<br>
<br>
Specific items from TypeScript we avoid:<br>
- Overloading &quot;+&quot;, using it both for addition and string concatenation.&nbsp;&nbsp;This<br>
&nbsp;&nbsp;goes against legacy Vim script and often leads to mistakes.&nbsp;&nbsp;For that reason<br>
&nbsp;&nbsp;we will keep using &quot;..&quot; for string concatenation.&nbsp;&nbsp;Lua also uses &quot;..&quot; this<br>
&nbsp;&nbsp;way.&nbsp;&nbsp;And it allows for conversion to string for more values.<br>
- TypeScript can use an expression like &quot;99 ||&nbsp;<span class="MissingTag">'yes'</span>&quot; in a condition, but<br>
&nbsp;&nbsp;cannot assign the value to a boolean.&nbsp;&nbsp;That is inconsistent and can be<br>
&nbsp;&nbsp;annoying.&nbsp;&nbsp;Vim recognizes an expression with &amp;&amp; or || and allows using the<br>
&nbsp;&nbsp;result as a bool.<br>
- TypeScript considers an empty string as Falsy, but an empty list or dict as<br>
&nbsp;&nbsp;Truthy.&nbsp;&nbsp;That is inconsistent.&nbsp;&nbsp;In Vim an empty list and dict are also<br>
&nbsp;&nbsp;Falsy.<br>
- TypeScript has various &quot;Readonly&quot; types, which have limited usefulness,<br>
&nbsp;&nbsp;since a type cast can remove the immutable nature.&nbsp;&nbsp;Vim locks the value,<br>
&nbsp;&nbsp;which is more flexible, but is only checked at runtime.<br>
<br>
<br>
<span class="PreProc">Import and Export</span><br>
<br>
A problem of legacy Vim script is that by default all functions and variables<br>
are global.&nbsp;&nbsp;It is possible to make them script-local, but then they are not<br>
available in other scripts.&nbsp;&nbsp;This defies the concept of a package that only<br>
exports selected items and keeps the rest local.<br>
<br>
In Vim9 script a mechanism very similar to the JavaScript import and export<br>
mechanism is supported.&nbsp;&nbsp;It is a variant to the existing&nbsp;<a class="Comment" href="repeat.html#:source">:source</a>&nbsp;command<br>
that works like one would expect:<br>
- Instead of making everything global by default, everything is script-local,<br>
&nbsp;&nbsp;unless exported.<br>
- When importing a script the symbols that are imported are explicitly listed,<br>
&nbsp;&nbsp;avoiding name conflicts and failures if functionality is added later.<br>
- The mechanism allows for writing a big, long script with a very clear API:<br>
&nbsp;&nbsp;the exported function(s) and class(es).<br>
- By using relative paths loading can be much faster for an import inside of a<br>
&nbsp;&nbsp;package, no need to search many directories.<br>
- Once an import has been used, it can be cached and loading it again can be<br>
&nbsp;&nbsp;avoided.<br>
- The Vim-specific use of &quot;s:&quot; to make things script-local can be dropped.<br>
<br>
When sourcing a Vim9 script from a legacy script, only the items defined<br>
globally can be used, not the exported items.&nbsp;&nbsp;Alternatives considered:<br>
- All the exported items become available as script-local items.&nbsp;&nbsp;This makes<br>
&nbsp;&nbsp;it uncontrollable what items get defined and likely soon leads to trouble.<br>
- Use the exported items and make them global.&nbsp;&nbsp;Disadvantage is that it's then<br>
&nbsp;&nbsp;not possible to avoid name clashes in the global namespace.<br>
- Completely disallow sourcing a Vim9 script, require using&nbsp;<a class="Comment" href="vim9.html#:import">:import</a>.&nbsp;&nbsp;That<br>
&nbsp;&nbsp;makes it difficult to use scripts for testing, or sourcing them from the<br>
&nbsp;&nbsp;command line to try them out.<br>
<span class="Todo">Note</span>&nbsp;that you can also use&nbsp;<a class="Comment" href="vim9.html#:import">:import</a>&nbsp;in legacy Vim script, see above.<br>
<br>
<br>
<span class="PreProc">Compiling functions early</span><br>
<br>
Functions are compiled when called or when&nbsp;<a class="Comment" href="vim9.html#:defcompile">:defcompile</a>&nbsp;is used.&nbsp;&nbsp;Why not<br>
compile them early, so that syntax and type errors are reported early?<br>
<br>
The functions can't be compiled right away when encountered, because there may<br>
be forward references to functions defined later.&nbsp;&nbsp;Consider defining functions<br>
A, B and C, where A calls B, B calls C, and C calls A again.&nbsp;&nbsp;It's impossible<br>
to reorder the functions to avoid forward references.<br>
<br>
An alternative would be to first scan through the file to locate items and<br>
figure out their type, so that forward references are found, and only then<br>
execute the script and compile the functions.&nbsp;&nbsp;This means the script has to be<br>
parsed twice, which is slower, and some conditions at the script level, such<br>
as checking if a feature is supported, are hard to use.&nbsp;&nbsp;An attempt was made<br>
to see if it works, but it turned out to be impossible to make work nicely.<br>
<br>
It would be possible to compile all the functions at the end of the script.<br>
The drawback is that if a function never gets called, the overhead of<br>
compiling it counts anyway.&nbsp;&nbsp;Since startup speed is very important, in most<br>
cases it's better to do it later and accept that syntax and type errors are<br>
only reported then.&nbsp;&nbsp;In case these errors should be found early, e.g. when<br>
testing, the&nbsp;<a class="Comment" href="vim9.html#:defcompile">:defcompile</a>&nbsp;command will help out.<br>
<br>
<br>
<span class="PreProc">Why not use an embeded language?</span><br>
<br>
Vim supports interfaces to Perl, Python, Lua, Tcl and a few others.&nbsp;&nbsp;But<br>
these interfaces have never become widely used, for various reasons.&nbsp;&nbsp;When<br>
Vim9 was designed a decision was made to make these interfaces lower priority<br>
and concentrate on Vim script.<br>
<br>
Still, plugin writers may find other languages more familiar, want to use<br>
existing libraries or see a performance benefit.&nbsp;&nbsp;We encourage plugin authors<br>
to write code in any language and run it as an external tool, using jobs and<br>
channels.&nbsp;&nbsp;We can try to make this easier somehow.<br>
<br>
Using an external tool also has disadvantages.&nbsp;&nbsp;An alternative is to convert<br>
the tool into Vim script.&nbsp;&nbsp;For that to be possible without too much<br>
translation, and keeping the code fast at the same time, the constructs of the<br>
tool need to be supported.&nbsp;&nbsp;Since most languages support classes the lack of<br>
support for classes in Vim is then a problem.<br>
<br>
<br>
<span class="PreProc">Classes</span><br>
<br>
Vim supports a kind-of object oriented programming by adding methods to a<br>
dictionary.&nbsp;&nbsp;With some care this can be made to work, but it does not look<br>
like real classes.&nbsp;&nbsp;On top of that, it's quite slow, because of the use of<br>
dictionaries.<br>
<br>
The support of classes in Vim9 script is a &quot;minimal common functionality&quot; of<br>
class support in most languages.&nbsp;&nbsp;It works much like Java, which is the most<br>
popular programming language.<br>
<br>
<br>
<br>
&nbsp;vim:tw=78:ts=8:noet:ft=help:norl:<br>
</div>
